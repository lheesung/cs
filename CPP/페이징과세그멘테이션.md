# 📑 페이징

페이징은 메모리를 비연속적인 공간으로 나누어 프로세스가 요청한 크기의 공간이 있으면 할당하는 방식이다. (비 연속적인 공간이라는것은 프로세스가 메모리에 순차적으로 적재되지 않아도 된다는 말이다.) 쉽게 말해 가상 메모리를 물리적인 메모리로 맵핑하는 것이다.
![Alt text](./images/image.png)
다음 그림과 같이 크기가 큰 메모리를 그보다 작은 단위인 블록으로 만들어 관리한다. 이 과정을 페이징이라고 하고 나눠진 블록들을 페이지라고 부른다.

### 페이지

페이지는 모두 서로 같은 크기를 가진다는 특징이 있다. 또 2^n의 크기를 사용한다. 보통 4KB를 할당한다.

### 페이지 VS 프레임

프레임은은 페이지와 비슷하게 메모리를 일정한 크기로 나눈 블럭이다. 하지만 프레임은 물리 메모리 다루고 있고 페이지는 가상 메모리를 다루고 있다.

### 페이징을 사용하는 이유

Memory Fragmentation 해결하기 위해서다.

> Memory Memory Fragmentation: RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 보고 메모리 단편화가 발생했다고 한다.

# 세그멘테이션

페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하는 것을 의미한다. 반면, 세그멘테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치하는 것을 의미한다. code, data, stack 영역으로 나뉘는 것도 세그멘테이션이라고 할 수 있다.세그멘테이션도 페이징과 비슷하게 세그먼트 테이블을 가지고 있다. 페이징과 비슷하게 논리주소가 이루어져 있다. 다만 다른 점은 세그먼트의 크기는 일정하지 않기 때문에 테이블에 limit 정보가 추가로 들어있다는 점이다. 만약 세그먼트의 크기를 초과하는 주소가 들어오면 인터럽트가 발생해 해당 프로세스는 강제로 종료된다.

# 세그멘테이션 VS 페이징

세그멘테이션은 rwx 권한을 테이블에 추가하는데, 이때 이것을 논리적으로 나누기 때문에 해당 비트를 설정하기 간단하고 안전하다. 반면, 페이징은 code+data+stack 영역이 존재할 때 이를 일정한 크기로 나누기 때문에 영역이 섞여 비트를 설정하기 까다로워질 수 있다. 공유의 측면에서도 마찬가지로, 페이징은 영역이 섞일 가능성이 존재하지만, 세그멘테이션은 정확히 영역을 나누므로 더 효율적으로 공유를 할 수 있다. 하지만, 현재 대부분은 페이징 기법을 세그멘테이션보다 많이 사용한다.
그 이유는 세그멘테이션의 세그먼트 크기가 일정하지 않고 다양하기 때문이다
